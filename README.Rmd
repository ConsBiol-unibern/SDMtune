---
output:
  github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "docs/reference/figures/README-"
)
```

# SDMsel <img src="logo.png" align="right" />

**SDMsel** (Species Distribution Model selection) provides a framework that facilitates preparing data for analysis, train and evaluate models. It also includes functions for data driven variable selection and model tuning and utilities to display results (at the moment it implements MaxEnt and Maxnet models).
**SDMsel** uses its own script to predict MaxEnt models that performs much faster for large datasets than native predictions made using Java software. This reduces considerably the computation time when tuning the model, especially when optimizing the **AICc**. 

## Installation

You can get the latest stable version from CRAN:

```{r CRAN-installation, eval=F}
install.packages("SDMsel")
```

or the latest development version from github:

```{r gh-installation, eval = FALSE}
devtools::install_github("sgvignali/SDMsel")
```

## Example

Load required packages:
```{r load packages}
library(SDMsel)
library(dismo)
```


Obtain the data for the analysis, we use the dataset provided by `dismo`package:

```{r obtain data}
files <- list.files(path = paste(system.file(package = "dismo"), "/ex", sep = ""), pattern = "grd", full.names = T)
predictors <- stack(files)
file <- paste(system.file(package = "dismo"), "/ex/bradypus.csv", sep = "")
bradypus <- read.table(file, header = TRUE, sep = ",")
train_coords <- bradypus[, 2:3]
set.seed(25)
bg_coords <- randomPoints(predictors, 5000)  # Extract random points
```

Prepare the data for the analysis with `SDMsel`:

```{r prepare data}
train <- prepareSWD(species = "Bradypus variegatus", coords = train_coords, env = predictors, categoricals = "biome")
bg <- prepareSWD(species = "Bradypus variegatus", coords = bg_coords, env = predictors, categoricals = "biome")
```

Train a MaxEnt model:

```{r train MaxEnt}
maxent_model <- train(method = "Maxent", presence = train, bg = bg, reg = 1, fc = "lqph")
```

Train a Maxnet model:

```{r train Maxnet}
maxnet_model <- train(method = "Maxnet", presence = train, bg = bg, reg = 1, fc = "lqph")
```

Plot the ROC curve:

```{r plot-ROC-curve maxent, fig.align="center"}
plotROC(maxent_model)
```


```{r plot-ROC-curve maxnet, fig.align="center"}
plotROC(maxnet_model)
```


Make prediction:

```{r predict maxent}
maxent_pred <- predict(maxent_model, data = predictors, type = "cloglog")
```

```{r predict maxnet}
maxnet_pred <- predict(maxnet_model, data = predictors, type = "cloglog")
```

Plot prediction:

```{r plot-prediction maxent, fig.align="center"}
plotPred(maxent_pred, lt = "cloglog output")
```

```{r plot-prediction maxnet, fig.align="center"}
plotPred(maxnet_pred, lt = "cloglog output")
```

# Speed test

We test now the difference in computation speed between the predict function of the **dismo** package that uses the Java software and the predict function of the **SDMsel** package. We also test if the results are equivalent.

The following code creates a function to test the equivalence of the results:

```{r}
my_check <- function(values) {
  error <- 1e-7 
  max_error <- max(values(values[[1]]) - values(values[[2]]), na.rm = T) 
  max_error < error
}
```

If the results diverge more than `1e-7` the test will fail. The next function converts an object of class `Maxent` into an object of class `MaxEnt` (dismo pkg):

```{r}
me_model <- SDMmodel2MaxEnt(maxent_model)
```

Run the test with 10 replicates:

```{r}
library(microbenchmark)
res <- microbenchmark("dismo" = pred <- {predict(me_model, predictors)},
                      "SDMsel" = pred <- {predict(maxent_model, predictors, type = "cloglog")},
                      times = 10,
                      check = my_check)
```

Print results:
```{r}
res
```

Plot results:

```{r, fig.align="center"}
autoplot(res)
```

**SDMsel** is at almost three times faster than the native Java software. The improvement in speed difference is even greater for large datasets when using parallel computation (i.e. see details in predict function).
