<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<script type="application/javascript">{{{ jQuery }}}</script>
	<script type="application/javascript">{{{ chartJs }}}</script>
	<title>{{ title }}</title>
	<style>
	canvas {
		-moz-user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}
	</style>
	<style type="text/css">{{{ style }}}</style>
</head>

<body>
	<div class="content">
		<div class="row">
			<canvas id="line"></canvas>
		</div>
	</div>

	<script>
		var data = {};

		var lineData = {
			datasets: [{
				label: "Training",
				pointRadius: 3,
				pointHoverRadius: 5,
				borderWidth: .7,
				borderColor: "rgb(75, 192, 192)",
				backgroundColor: "rgba(75, 192, 192, .7)",
				data: [],
				fill: false,
				lineTension: 0
			}]
		};
		// Add Validation dataset if metric in not AICc
		if ("{{ metric }}" !== "AICc") {
			lineData.datasets.push({
				label: "Validation",
				pointRadius: 3,
				pointHoverRadius: 5,
				borderWidth: .7,
				borderColor: "rgb(245, 132, 16)",
				backgroundColor: "rgba(245, 132, 16, .7)",
				data: [],
				fill: false,
				lineTension: 0
			})
		}

		var lineOptions = {
			responsive: true,
			title: {
				display: true,
				fontFamily: "sans-serif",
				padding: 15,
				text: "{{ title }}"
			},
			legend: {
				position: "bottom",
				labels: {
					fontFamily: "sans-serif",
					usePointStyle: true
				}
			},
			scales: {
				yAxes: [{
					scaleLabel: {
						display: true,
						labelString: "{{ metric }}"
					}
				}],
				xAxes: [{
				  type: "linear",
					scaleLabel: {
						display: true,
						labelString: "{{ x_label }}",
					},
					ticks: {
						suggestedMin: parseInt("{{ min }}"),
            suggestedMax: parseInt("{{ max }}"),
            autoSkip: false
					}
				}]
			},
			tooltips: {
				mode: "x",
				footerFontStyle: "normal",
				callbacks: {
					label: function(tooltipItem, data) {
						var label = data.datasets[tooltipItem.datasetIndex].label || "";
						if (label) {
							label += ": ";
						}
						label += tooltipItem.yLabel;
						return label;
					},
					title: function(tooltipItems, data) {
						return ""
					},
          footer: function(tooltipItems, data) {
						return window.data.lineFooter[tooltipItems[0].index]
					}
				}
			}
		};

		if ("{{ x_label }}" === "feature combination") {
      lineOptions.scales.xAxes[0].type = "category";
      lineOptions.scales.xAxes[0].labels = {{{ labels }}};
    }

		update = function() {
			var refresh = setInterval(loadData, 1000);
			function loadData() {
				$.ajax({
					method: "GET",
					url: "data.json",
					cache: false
				})
				.done(function (json) {
					data = JSON.parse(json)
					window.chartLine.data.datasets[0].data = data.train;
					if ("{{ metric }}" !== "AICc") {
						window.chartLine.data.datasets[1].data = data.val;
					}
					window.chartLine.update();

					if (data.stop[0]) {
						clearInterval(refresh);
					}
				})
			};
		};

		window.onload = function() {
			// Set a wider content if page is displayed in the browser
			if (window.location.href.search("[?&]viewer_pane=") === -1) {
				document.querySelector(".content").style.maxWidth="600px";
			}
			var ctx = document.getElementById("line").getContext("2d");
			window.chartLine = new Chart(ctx, {
				type: "line",
				data: lineData,
				options: lineOptions,
			});
			update();
		};

	</script>
</body>

</html>
